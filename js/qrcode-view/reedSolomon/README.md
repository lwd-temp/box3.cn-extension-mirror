#纠错码字的生成#

QR 码的多项式算法用位的*模 2 算法*和字节的模 *100011101 算法*。这是有限域加罗瓦域 GF(2^8) 以
100011101 本质多项式:*x\^8\+x\^4\+x\^3\+x\^2\+1*。

##数据码字多项式生成##
数据码字为多项式各项的系数, 第一个数据码字为最高次项的系数,最低次项的系数是第一个纠错码字前的最后一个数据码字。
> 例如（版本1—M,数据码字容量为16个码字)
>
> 数据码字为
>
> 00010000   00100000   00001100   01010110   01100001   10000000

> 11101100   00010001   11101100   00010001   11101100   00010001

> 11101100   00010001   11101100   00010001
>
> 转为数据码多项式
>
>16x\^15 + 32x\^14 + 12x\^13 + 86x\^12 + 97x\^11 + 128x\^10 + 236x\^9 + 17x\^8 + 236x\^7 + 17x\^6 +
236x\^5 + 17x\^4 + 236x\^3 + 17x\^2 + 236x\^1 + 17x\^0

---

纠错码字是数据码字被纠错码多项式 g(x)除得的余数。余数的最高次项系
数为第一个纠错码字,最低次项系数为最后一个纠错码字,也是整个块的最后一个码字。

---

##纠错码字多项式生成##
纠错码字多项式由每个版本和纠错等级所对应的纠错码字的生成多项式,每一生成多项式是一元多项式x+2\^0, x+2\^1, ..., x+2\^n-1的乘积,其中n是纠错码字数。
> 例如（版本1—M,需要10个纠错码字)
>
> (x + 2\^0)(x + 2\^1)(x + 2\^2)(x + 2\^3)(x + 2\^4)(x + 2\^5)(x + 2\^6)(x + 2\^7)(x + 2\^8)(x + 2\^9)
>
> x\^10 + 2\^251x\^9 + 2\^67x\^8 + 2\^46x\^7 + 2\^61x\^6 + 2\^118x\^5 + 2\^70x\^4 + 2\^64x\^3  + 2\^94x\^2 + 2\^32x\^1+2\^45x\^0

由于多项式的每个系数都是在有限域加罗瓦域 GF(2^8) 上的基元,必须保证所声称的码字在(0~255)范围内, 对于大于2^7, 2^n 等于2^n-1与模*10001101*进行异或操作, 计算后的纠错码为

> 11011000   11000010   10011111   01101111   11000111   01011110   01011111   01110001   10011101   11000001

通过多项式除法,设数据码字为F,纠错多项式为G,(F<<10)/G的商为Q、余数为R (即F<<10 == Q*G + R),则最终的编码信息
 C = (F << 10) ^ ((F << 10) mod G) = (Q*G + R) - (Q*G + R) mod G = (Q*G + R) - R = Q*G,
 从而C应当是能够被G整除的。如果收到的C不能被G整除,说明传输出错了

用数据码字除以纠错码字,所得的商为

> 10100101   00100100   11010100   11000001   11101101   00110110

> 11000111   10000111   00101100   01010101

用数据码字加上商,则最后声称的数据块为

> 00010000   00100000   00001100   01010110   01100001   10000000

> 11101100   00010001   11101100   00010001   11101100   00010001

> 11101100   00010001   11101100   00010001   10100101   00100100

> 11010100   11000001   11101101   00110110   11000111   10000111

> 00101100   01010101


##纠错的判断和实现##

前面说到编码信息 C = Q * G,由于每个数据块的纠错码数是固定的,这时我们可以预先生成好纠错多项式G, 通过判断 C % G == 0 来验证识别到的编码信息是否正确
